// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/browser/android/content_view_impl.h"

#include "base/android/jni_android.h"
#include "base/android/scoped_java_ref.h"
// Once the TODO(jrg) for namespaces in jni generation is resolved
// (below), we won't need the next two headers.
#include "base/basictypes.h"
#include "base/logging.h"

// TODO(jrg): content_view_jni.h is generated by
// base/android/jni_generator/jni_generator.py from ContentView.java.
// But the script doesn't know about the content namespace.  Fix gyp
// rules to define a namespace variable; fix jni_generator.gypi to
// pass namespace to the script; fix the script to apply namespace on
// generation.
// Until that is done, we must wrap this in the content namespace,
// since otherwise the class ContentView is referenced in the
// generated header without the proper namespace.  b/6597416
namespace content {
#include "jni/content_view_jni.h"
};

using base::android::GetClass;
using base::android::HasField;

namespace {
jfieldID g_native_content_view;
}  // namespace


namespace content {

// ----------------------------------------------------------------------------
// Implementation of static ContentView public interfaces

ContentView* ContentView::Create(JNIEnv* env, jobject obj) {
  return new ContentViewImpl(env, obj);
}

ContentView* ContentView::GetNativeContentView(JNIEnv* env, jobject obj) {
  return reinterpret_cast<ContentView*>(
      env->GetIntField(obj, g_native_content_view));
}

// ----------------------------------------------------------------------------

ContentViewImpl::ContentViewImpl(JNIEnv* env, jobject obj) {
}

ContentViewImpl::~ContentViewImpl() {
}

void ContentViewImpl::Destroy(JNIEnv* env, jobject obj) {
  delete this;
}

void ContentViewImpl::Observe(int type,
                              const NotificationSource& source,
                              const NotificationDetails& details) {
  // TODO(jrg)
}

// ----------------------------------------------------------------------------
// Native JNI methods
// ----------------------------------------------------------------------------

// This is called for each ContentView.
// TODO(jrg): add extra args (e.g. hardware_accelerated,
// native_web_contents) once other pieces are upstreamed.
static jint Init(JNIEnv* env, jobject obj) {
  ContentView* view = ContentView::Create(env, obj);
  return reinterpret_cast<jint>(view);
}

// ----------------------------------------------------------------------------

bool RegisterContentView(JNIEnv* env) {
  if (!base::android::HasClass(env, kContentViewClassPath)) {
    DLOG(ERROR) << "Unable to find class ContentView!";
    return false;
  }
  ScopedJavaLocalRef<jclass> clazz = GetClass(env, kContentViewClassPath);
  if (!HasField(env, clazz, "mNativeContentView", "I")) {
    DLOG(ERROR) << "Unable to find ContentView.mNativeContentView!";
    return false;
  }
  g_native_content_view = GetFieldID(env, clazz, "mNativeContentView", "I");

  return RegisterNativesImpl(env) >= 0;
}

};  // namespace content
